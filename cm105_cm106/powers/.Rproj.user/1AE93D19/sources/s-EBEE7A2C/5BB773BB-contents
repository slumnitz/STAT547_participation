---
title: 'Homework 06: Data wrangling wrap up'
author: Stefanie Lumnitz
date: "`r format(Sys.time(), '%d %B, %Y')`"   
output:  
  github_document:  
    toc: yes
always_allow_html: yes
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(error = TRUE, collapse = TRUE, comment = "#>")
```

### Load required packages

```{r}
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(scales))
suppressPackageStartupMessages(library(gganimate))
```


## Exercise 4: Geospatial R and the `singer` data

The `singer_location` dataframe in the `singer` package contains geographical information stored in two different formats: 1. as a (dirty!) variable named `city`; 2. as a latitude / longitude pair (stored in `latitude`, `longitude` respectively). I am trying to clean up the `city` variable by adding addresses in the same format to each observation respectively. I will herefore use a technique called:

> **Reverse geocoding** is the process of converting geographic coordinates into a human-readable address.

**revgeocode**:
> reverse geocodes a longitude/latitude location using Google Maps. Note that in most cases by using this function you are agreeing to the Google Maps API Terms of Service at https://developers.google.com/maps/terms.

[**Google Maps API**](https://developers.google.com/maps/documentation/geocoding/start?csw=1)

```{r}
library(singer)
library(leaflet)
suppressPackageStartupMessages(library(ggmap))
```

Let's assess first what teh singer dataset contains, before starting to manipulate it:

```{r}
glimpse(singer_locations)
```

```{r}
mysummary_table <- function(df) {
  tab <- data.frame(
    "rows" = nrow(df))
  return(tab)
}
```


```{r}
geo_singer <- singer_locations %>% 
  select(artist = artist_name,
         latitude = latitude,
         longitude = longitude,
         city = city,
         hottness = artist_hotttnesss,
         familiarity = artist_familiarity)
```


```{r}
geo_singer_clean <- geo_singer %>% 
  distinct(artist, .keep_all = TRUE) %>% # remove duplicate artist names
  na.omit(cols=c("latitude", "longitude")) # remove all rows with NA values in lat or lon

geo_singer_clean %>% 
  head(10) %>% 
  kable()
```

```{r}
mysummary_table(geo_singer)
mysummary_table(geo_singer_clean)
```

I discovered very late that `revgeocode` needs an official Google MAPs API key now. I need this very same API key every day for my Masters research project and am using up the query limit for the API daily. Nevertheless, I will use ggmap to display my geolocation results:

```{r}
geo_singer_clean$latitude
```


```{r}
singer_city <-
  map2(geo_singer_clean$longitude, geo_singer_clean$latitude, revgeo)
singer_city
```
```{r}
library(revgeo)
```

```{r}
revgeo(longitude=-77.0229529, latitude=38.89283435)
```

```{r}
singer_locations %>%  
  leaflet()  %>%   
  addTiles() %>%  
  addCircles(popup = ~artist_name)
```

